<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Asteroid Shooter</title>
  <style>
    :root { --bg: #070A12; --panel: rgba(255,255,255,.06); --text: rgba(255,255,255,.92); --muted: rgba(255,255,255,.6); }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { overflow: hidden; }

    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; }

    /* HUD */
    #hud {
      position: fixed;
      top: env(safe-area-inset-top);
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      pointer-events: none;
      user-select: none;
      z-index: 3;
    }
    .pill {
      pointer-events: none;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 8px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-weight: 700;
      letter-spacing: .2px;
      font-size: 14px;
    }
    #titlePill { font-weight: 800; }
    #scorePill { margin-left: auto; text-align: right; min-width: 132px; }
    #scorePill small { display: block; font-weight: 700; color: var(--muted); letter-spacing: .2px; }

    /* Overlay */
    #overlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      padding: 22px;
      z-index: 4;
      background:
        radial-gradient(1200px 600px at 50% 15%, rgba(120,160,255,.20), transparent 60%),
        radial-gradient(900px 500px at 80% 70%, rgba(255,120,180,.12), transparent 55%),
        rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #card {
      width: min(520px, 100%);
      background: rgba(10,12,20,.65);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    #card h1 {
      margin: 0 0 8px;
      font-size: 22px;
      letter-spacing: .2px;
    }
    #card p { margin: 0 0 12px; color: var(--muted); line-height: 1.35; font-weight: 600; }
    #startBtn {
      width: 100%;
      appearance: none;
      border: 0;
      border-radius: 16px;
      padding: 16px 16px;
      font-size: 18px;
      font-weight: 900;
      letter-spacing: .3px;
      background: linear-gradient(135deg, rgba(120,160,255,.95), rgba(255,120,180,.92));
      color: #06070c;
      box-shadow: 0 16px 40px rgba(120,160,255,.18);
    }
    #startBtn:active { transform: translateY(1px) scale(0.995); }
    #metaRow {
      display: flex; gap: 10px; flex-wrap: wrap;
      margin-top: 12px;
    }
    .chip {
      flex: 1 1 140px;
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      color: var(--muted);
      font-weight: 700;
      font-size: 13px;
      line-height: 1.25;
    }
    .chip b { color: var(--text); }
    #hint { margin-top: 10px; font-size: 13px; color: rgba(255,255,255,.72); font-weight: 700; }

    /* Bottom slingshot zone indicator (subtle) */
    #zone {
      position: fixed;
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      bottom: env(safe-area-inset-bottom);
      height: 26%;
      z-index: 2;
      pointer-events: none;
      background: linear-gradient(to top, rgba(255,255,255,.06), transparent 60%);
      border-top: 1px solid rgba(255,255,255,.08);
      opacity: .35;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div id="hud" aria-hidden="true">
    <div id="titlePill" class="pill">Asteroid Shooter</div>
    <div id="scorePill" class="pill">
      <small>SCORE</small>
      <span id="scoreTxt">0</span>
      <small style="margin-top:4px;">HIGH&nbsp;<span id="highTxt">0</span></small>
    </div>
  </div>

  <div id="zone" aria-hidden="true"></div>

  <div id="overlay" role="dialog" aria-modal="true">
    <div id="card">
      <h1>Asteroid Shooter</h1>
      <p><b>Shoot the asteroids.</b> Pull down in the bottom zone to charge, then release to slingshot a ball upward.</p>
      <button id="startBtn">Click to start</button>
      <div id="metaRow">
        <div class="chip"><b>How to play</b><br/>Drag down ➜ release to shoot</div>
        <div class="chip"><b>Goal</b><br/>Hit asteroids, don’t let them reach the bottom</div>
        <div class="chip"><b>High score</b><br/>Stays while this tab stays open</div>
      </div>
      <div id="hint">Tip: Longer pull = stronger shot.</div>
    </div>
  </div>

  <script>
    // ===== Utilities =====
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random() * (b - a);
    const dist2 = (ax, ay, bx, by) => {
      const dx = ax - bx, dy = ay - by;
      return dx*dx + dy*dy;
    };

    // ===== Canvas setup =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    let W = 0, H = 0, DPR = 1;
    function resize() {
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // ===== UI refs =====
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const scoreTxt = document.getElementById('scoreTxt');
    const highTxt  = document.getElementById('highTxt');

    // High score "while tab is open" => sessionStorage
    const HS_KEY = 'AS_HIGH_SCORE_V1';
    let highScore = Number(sessionStorage.getItem(HS_KEY) || 0);
    highTxt.textContent = String(highScore);

    // ===== Game state =====
    let running = false;
    let gameOver = false;

    let score = 0;

    // Slingshot zone is bottom ~26% (matches CSS zone)
    function zoneTop() { return H * 0.74; }

    // Stars
    const stars = [];
    function initStars() {
      stars.length = 0;
      const n = Math.floor((W * H) / 14000);
      for (let i = 0; i < n; i++) {
        stars.push({
          x: Math.random() * W,
          y: Math.random() * H,
          r: rand(0.6, 1.6),
          s: rand(0.12, 0.5) // speed
        });
      }
    }
    initStars();

    // Projectile (the slingshot ball)
    const ball = {
      x: W * 0.5,
      y: H * 0.92,
      vx: 0,
      vy: 0,
      r: 10,
      active: false
    };

    // Asteroids
    const asteroids = [];
    let spawnTimer = 0;
    let spawnEvery = 900; // ms, decreases with score
    let speedBase  = 140; // px/s

    // Particles
    const particles = [];

    // Input
    let pointerDown = false;
    let pullStart = { x: 0, y: 0 };
    let pullNow   = { x: 0, y: 0 };
    let pullPower = 0; // 0..1
    let pullValid = false;

    // Time
    let lastT = 0;

    // ===== Audio (simple beep for hits) =====
    let audioCtx = null;
    function beep(freq = 440, dur = 0.05, type = 'sine', gain = 0.03) {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t0 = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);
        g.gain.setValueAtTime(gain, t0);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(t0);
        o.stop(t0 + dur);
      } catch {}
    }

    // ===== Game functions =====
    function resetGame() {
      score = 0;
      scoreTxt.textContent = '0';

      asteroids.length = 0;
      particles.length = 0;

      ball.x = W * 0.5;
      ball.y = H * 0.92;
      ball.vx = 0;
      ball.vy = 0;
      ball.active = false;
      ball.r = clamp(Math.min(W, H) * 0.018, 8, 12);

      spawnTimer = 0;
      spawnEvery = 900;
      speedBase  = 140;

      pointerDown = false;
      pullPower = 0;
      pullValid = false;

      gameOver = false;
    }

    function endGame() {
      running = false;
      gameOver = true;

      // Update high score
      if (score > highScore) {
        highScore = score;
        sessionStorage.setItem(HS_KEY, String(highScore));
        highTxt.textContent = String(highScore);
      }

      // Show overlay with try again
      overlay.style.display = 'grid';
      const h1 = overlay.querySelector('h1');
      const p  = overlay.querySelector('p');
      h1.textContent = score >= highScore ? 'New High Score!' : 'Game Over';
      p.innerHTML = `<b>Shoot the asteroids.</b> Score: <b>${score}</b> • High: <b>${highScore}</b>`;
      startBtn.textContent = 'Try again';
    }

    function spawnAsteroid() {
      const r = rand(14, 26) * (Math.min(W, H) / 700);
      const x = rand(r + 8, W - r - 8);
      const y = -r - 8;
      const drift = rand(-40, 40);
      const speed = speedBase + rand(0, 80) + Math.min(220, score * 1.2);
      asteroids.push({
        x, y, r,
        vx: drift,
        vy: speed,
        hp: 1,
        spin: rand(-3, 3),
        a: rand(0, Math.PI * 2)
      });
    }

    function explode(x, y, base = 14) {
      const n = Math.floor(base + rand(0, base));
      for (let i = 0; i < n; i++) {
        const ang = rand(0, Math.PI * 2);
        const sp = rand(70, 260);
        particles.push({
          x, y,
          vx: Math.cos(ang) * sp,
          vy: Math.sin(ang) * sp,
          r: rand(1.2, 2.8),
          life: rand(0.25, 0.6),
          t: 0
        });
      }
    }

    function shootFromPull() {
      if (ball.active) return; // one shot at a time
      // Launch direction: opposite of pull vector (release slingshot)
      const dx = pullStart.x - pullNow.x;
      const dy = pullStart.y - pullNow.y;

      const mag = Math.hypot(dx, dy);
      if (mag < 10) return;

      const maxPower = clamp(pullPower, 0, 1);
      // Ensure generally upward bias so it feels good
      const dirx = dx / mag;
      const diry = dy / mag;

      const launchSpeed = 700 * (0.25 + 0.75 * maxPower); // px/s
      ball.x = clamp(pullStart.x, ball.r + 2, W - ball.r - 2);
      ball.y = clamp(pullStart.y, zoneTop() + ball.r + 6, H - ball.r - 6);
      ball.vx = dirx * launchSpeed;
      ball.vy = diry * launchSpeed;

      // If user pulls mostly sideways, keep it sane
      if (ball.vy > -120) ball.vy = -120 - 460 * maxPower;

      ball.active = true;
      beep(520, 0.04, 'triangle', 0.03);
    }

    // ===== Input handlers =====
    function getPoint(e) {
      if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }

    function onDown(e) {
      if (!running) return;
      const p = getPoint(e);
      pointerDown = true;
      pullStart = p;
      pullNow = p;
      pullPower = 0;
      pullValid = (p.y >= zoneTop());
    }

    function onMove(e) {
      if (!running || !pointerDown) return;
      const p = getPoint(e);
      pullNow = p;

      if (!pullValid) return;

      // Pull is downwards (increasing y)
      const dy = p.y - pullStart.y;
      const dx = p.x - pullStart.x;
      const raw = Math.hypot(dx, dy);

      // Only count pulls that go "down" at least a bit
      const downBias = dy > 0 ? 1 : 0.25;
      const maxPull = Math.min(H * 0.22, 180);
      pullPower = clamp((raw * downBias) / maxPull, 0, 1);
    }

    function onUp(e) {
      if (!running) return;
      if (pointerDown && pullValid) {
        shootFromPull();
      }
      pointerDown = false;
      pullPower = 0;
      pullValid = false;
    }

    canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture?.(e.pointerId); onDown(e); }, { passive: true });
    canvas.addEventListener('pointermove', onMove, { passive: true });
    canvas.addEventListener('pointerup', onUp, { passive: true });
    canvas.addEventListener('pointercancel', onUp, { passive: true });

    // Prevent scroll/overscroll on iOS while playing
    document.addEventListener('touchmove', (e) => { if (running) e.preventDefault(); }, { passive: false });

    // ===== Main loop =====
    function step(t) {
      requestAnimationFrame(step);
      const dt = Math.min(0.033, (t - lastT) / 1000 || 0.016);
      lastT = t;

      // Background stars drift
      for (const s of stars) {
        s.y += s.s * 60 * dt;
        if (s.y > H + 2) { s.y = -2; s.x = Math.random() * W; }
      }

      if (running && !gameOver) update(dt);
      render(dt);
    }

    function update(dt) {
      // Difficulty scales with score
      spawnEvery = clamp(900 - score * 2.2, 280, 900);
      speedBase  = 140 + Math.min(220, score * 0.9);

      // Spawn asteroids
      spawnTimer += dt * 1000;
      while (spawnTimer >= spawnEvery) {
        spawnTimer -= spawnEvery;
        spawnAsteroid();
        if (Math.random() < 0.12) spawnAsteroid(); // occasional double
      }

      // Ball physics
      if (ball.active) {
        // Gravity-ish downward
        ball.vy += 520 * dt;

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // Wall bounce
        if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.9; }
        if (ball.x > W - ball.r) { ball.x = W - ball.r; ball.vx *= -0.9; }
        if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -0.85; }

        // If it falls back into bottom zone, "catch" it and reset for next shot
        if (ball.y > H + ball.r * 2) {
          ball.active = false;
          ball.x = W * 0.5;
          ball.y = H * 0.92;
          ball.vx = 0; ball.vy = 0;
        }
      }

      // Asteroids move
      const bottomLine = zoneTop() + 12; // reaching near slingshot zone ends game
      for (let i = asteroids.length - 1; i >= 0; i--) {
        const a = asteroids[i];
        a.a += a.spin * dt;
        a.x += a.vx * dt;
        a.y += a.vy * dt;

        // Gentle side wrap
        if (a.x < -a.r) a.x = W + a.r;
        if (a.x > W + a.r) a.x = -a.r;

        // Collision with ball
        if (ball.active) {
          const rr = (a.r + ball.r);
          if (dist2(a.x, a.y, ball.x, ball.y) <= rr * rr) {
            // Score + destroy
            score += 10;
            scoreTxt.textContent = String(score);

            // Knock ball a bit
            const nx = (ball.x - a.x);
            const ny = (ball.y - a.y);
            const nm = Math.hypot(nx, ny) || 1;
            const ux = nx / nm, uy = ny / nm;
            ball.vx += ux * 120;
            ball.vy += uy * 120;

            explode(a.x, a.y, 16);
            beep(220 + Math.min(880, score * 2), 0.04, 'square', 0.025);

            asteroids.splice(i, 1);
            continue;
          }
        }

        // If any asteroid reaches the bottom, game over
        if (a.y + a.r >= bottomLine) {
          explode(a.x, a.y, 22);
          beep(120, 0.12, 'sawtooth', 0.03);
          endGame();
          break;
        }

        // Cleanup if far past screen (shouldn't happen before game over)
        if (a.y - a.r > H + 120) asteroids.splice(i, 1);
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.t += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= Math.pow(0.08, dt); // damping
        p.vy *= Math.pow(0.08, dt);
        if (p.t >= p.life) particles.splice(i, 1);
      }
    }

    function render(dt) {
      // Clear
      ctx.fillStyle = '#070A12';
      ctx.fillRect(0, 0, W, H);

      // Subtle vignette
      const g = ctx.createRadialGradient(W*0.5, H*0.35, 10, W*0.5, H*0.5, Math.max(W,H));
      g.addColorStop(0, 'rgba(120,160,255,0.08)');
      g.addColorStop(0.6, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.55)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // Stars
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      for (const s of stars) {
        ctx.globalAlpha = clamp(0.35 + s.r * 0.25, 0.25, 0.9);
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Slingshot guide line (only while pulling)
      if (running && pointerDown && pullValid) {
        const sx = pullStart.x, sy = pullStart.y;
        const ex = pullNow.x,   ey = pullNow.y;
        // draw tension line
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.strokeStyle = `rgba(255,255,255,${0.22 + 0.35 * pullPower})`;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        // power ring
        ctx.strokeStyle = `rgba(120,160,255,${0.25 + 0.45 * pullPower})`;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(sx, sy, 12 + 28 * pullPower, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Asteroids
      for (const a of asteroids) {
        // rocky gradient
        const ag = ctx.createRadialGradient(a.x - a.r*0.25, a.y - a.r*0.25, 2, a.x, a.y, a.r*1.2);
        ag.addColorStop(0, 'rgba(255,255,255,0.18)');
        ag.addColorStop(0.4, 'rgba(180,190,210,0.14)');
        ag.addColorStop(1, 'rgba(80,90,120,0.55)');
        ctx.fillStyle = ag;

        ctx.beginPath();
        ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
        ctx.fill();

        // craters
        ctx.globalAlpha = 0.65;
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        for (let i = 0; i < 3; i++) {
          const cx = a.x + Math.cos(a.a + i) * a.r * 0.35;
          const cy = a.y + Math.sin(a.a * 1.2 + i*1.7) * a.r * 0.25;
          ctx.beginPath();
          ctx.arc(cx, cy, a.r * rand(0.12, 0.22), 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // outline
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Ball
      if (running) {
        // resting hint (when not active, show ball at bottom)
        const bx = ball.active ? ball.x : (pointerDown && pullValid ? pullStart.x : W*0.5);
        const by = ball.active ? ball.y : (pointerDown && pullValid ? pullStart.y : H*0.92);

        const bg = ctx.createRadialGradient(bx - ball.r*0.3, by - ball.r*0.3, 2, bx, by, ball.r*1.6);
        bg.addColorStop(0, 'rgba(255,255,255,0.95)');
        bg.addColorStop(0.4, 'rgba(120,160,255,0.75)');
        bg.addColorStop(1, 'rgba(255,120,180,0.20)');
        ctx.fillStyle = bg;
        ctx.beginPath();
        ctx.arc(bx, by, ball.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(bx, by, ball.r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Particles
      for (const p of particles) {
        const a = 1 - (p.t / p.life);
        ctx.globalAlpha = a;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Bottom "danger line" (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.10)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, zoneTop());
      ctx.lineTo(W, zoneTop());
      ctx.stroke();

      // If not running, dim
      if (!running) {
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, W, H);
      }
    }

    // ===== Start button =====
    function startGame() {
      overlay.style.display = 'none';
      resetGame();
      running = true;
      gameOver = false;

      // iOS audio unlock
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          // tiny silent tick
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          g.gain.value = 0.00001;
          o.connect(g); g.connect(audioCtx.destination);
          o.start(); o.stop(audioCtx.currentTime + 0.01);
        } catch {}
      }
    }

    startBtn.addEventListener('click', startGame);

    // ===== Kick off loop =====
    requestAnimationFrame(step);

    // Keep stars density reasonable if orientation changes a lot
    let lastWH = W + 'x' + H;
    setInterval(() => {
      const now = window.innerWidth + 'x' + window.innerHeight;
      if (now !== lastWH) { lastWH = now; initStars(); }
    }, 700);
  </script>
</body>
</html>