<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Asteroid Shooter</title>
  <style>
    :root { --bg:#070A12; --panel:rgba(255,255,255,.06); --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.6); }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    body{overflow:hidden}
    #wrap{position:fixed;inset:0;display:grid;place-items:center}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none}
    #hud{
      position:fixed;top:env(safe-area-inset-top);left:env(safe-area-inset-left);right:env(safe-area-inset-right);
      padding:12px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px;pointer-events:none;user-select:none;z-index:3
    }
    .pill{
      background:var(--panel);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:8px 12px;
      backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);font-weight:700;letter-spacing:.2px;font-size:14px
    }
    #titlePill{font-weight:800}
    #scorePill{margin-left:auto;text-align:right;min-width:132px}
    #scorePill small{display:block;font-weight:700;color:var(--muted);letter-spacing:.2px}
    #overlay{
      position:fixed;inset:0;display:grid;place-items:center;padding:22px;z-index:4;
      background:radial-gradient(1200px 600px at 50% 15%, rgba(120,160,255,.20), transparent 60%),
               radial-gradient(900px 500px at 80% 70%, rgba(255,120,180,.12), transparent 55%),
               rgba(0,0,0,.55);
      backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px)
    }
    #card{
      width:min(520px,100%);background:rgba(10,12,20,.65);border:1px solid rgba(255,255,255,.14);
      border-radius:18px;padding:18px;box-shadow:0 18px 60px rgba(0,0,0,.55)
    }
    #card h1{margin:0 0 8px;font-size:22px;letter-spacing:.2px}
    #card p{margin:0 0 12px;color:var(--muted);line-height:1.35;font-weight:600}
    #startBtn{
      width:100%;appearance:none;border:0;border-radius:16px;padding:16px 16px;font-size:18px;font-weight:900;letter-spacing:.3px;
      background:linear-gradient(135deg, rgba(120,160,255,.95), rgba(255,120,180,.92));color:#06070c;box-shadow:0 16px 40px rgba(120,160,255,.18)
    }
    #startBtn:active{transform:translateY(1px) scale(.995)}
    #metaRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .chip{
      flex:1 1 140px;border-radius:12px;padding:10px 12px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);color:var(--muted);font-weight:700;font-size:13px;line-height:1.25
    }
    .chip b{color:var(--text)}
    #hint{margin-top:10px;font-size:13px;color:rgba(255,255,255,.72);font-weight:700}

    /* Bottom "slingshot zone" indicator */
    #zone{
      position:fixed;left:env(safe-area-inset-left);right:env(safe-area-inset-right);bottom:env(safe-area-inset-bottom);
      height:30%; /* a bit taller so you can pull more */
      z-index:2;pointer-events:none;
      background:linear-gradient(to top, rgba(255,255,255,.06), transparent 60%);
      border-top:1px solid rgba(255,255,255,.08);opacity:.35
    }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c"></canvas></div>

  <div id="hud" aria-hidden="true">
    <div id="titlePill" class="pill">Asteroid Shooter</div>
    <div id="scorePill" class="pill">
      <small>SCORE</small><span id="scoreTxt">0</span>
      <small style="margin-top:4px;">HIGH&nbsp;<span id="highTxt">0</span></small>
    </div>
  </div>

  <div id="zone" aria-hidden="true"></div>

  <div id="overlay" role="dialog" aria-modal="true">
    <div id="card">
      <h1>Asteroid Shooter</h1>
      <p><b>Shoot the asteroids.</b> Pull down in the bottom zone to charge, then release to slingshot a ball upward.</p>
      <button id="startBtn">Click to start</button>
      <div id="metaRow">
        <div class="chip"><b>How to play</b><br/>Drag down ➜ release to shoot</div>
        <div class="chip"><b>Goal</b><br/>Hit asteroids, don’t let them reach the bottom</div>
        <div class="chip"><b>High score</b><br/>Stays while this tab stays open</div>
      </div>
      <div id="hint">Tip: Longer pull = stronger shot. Rapid-fire is on.</div>
    </div>
  </div>

  <script>
    // ===== Utilities =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);
    const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

    // ===== Canvas setup =====
    const canvas=document.getElementById('c');
    const ctx=canvas.getContext('2d',{alpha:false});
    let W=0,H=0,DPR=1;

    function resize(){
      DPR=Math.max(1,Math.min(3,window.devicePixelRatio||1));
      W=Math.floor(window.innerWidth);
      H=Math.floor(window.innerHeight);
      canvas.width=Math.floor(W*DPR);
      canvas.height=Math.floor(H*DPR);
      canvas.style.width=W+'px';
      canvas.style.height=H+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
      initStars();
    }
    window.addEventListener('resize',resize,{passive:true});
    resize();

    // ===== UI refs =====
    const overlay=document.getElementById('overlay');
    const startBtn=document.getElementById('startBtn');
    const scoreTxt=document.getElementById('scoreTxt');
    const highTxt=document.getElementById('highTxt');

    // High score while tab is open => sessionStorage
    const HS_KEY='AS_HIGH_SCORE_V2';
    let highScore=Number(sessionStorage.getItem(HS_KEY)||0);
    highTxt.textContent=String(highScore);

    // ===== Game tuning (changed) =====
    const TUNE = {
      zoneHeightFrac: 0.30,     // bottom zone height fraction
      cradleYFrac: 0.82,        // ball "ready" height (higher than before)
      maxPullFrac: 0.32,        // pull distance relative to screen height
      maxPullPxCap: 280,        // hard cap so it’s consistent
      launchSpeedMin: 820,      // stronger than before
      launchSpeedMax: 1550,     // much stronger
      upwardBiasMin: 520,       // ensures vertical oomph
      shotCooldown: 0.06,       // rapid-fire: minimum time between shots
      ballAutoResetY: 0.88      // if a shot ball falls below this, reset it
    };

    // ===== Game state =====
    let running=false;
    let gameOver=false;
    let score=0;

    // Slingshot zone top line
    function zoneTop(){ return H*(1 - TUNE.zoneHeightFrac); }

    // ===== Stars =====
    const stars=[];
    function initStars(){
      stars.length=0;
      const n=Math.floor((W*H)/14000);
      for(let i=0;i<n;i++){
        stars.push({x:Math.random()*W,y:Math.random()*H,r:rand(0.6,1.6),s:rand(0.12,0.5)});
      }
    }

    // ===== Balls (changed to rapid-fire multi-ball) =====
    const balls=[]; // active shots
    function readyBallPos(){
      return { x: W*0.5, y: H*TUNE.cradleYFrac };
    }

    // the "ready ball" you pull from
    const readyBall = { x:0,y:0,r:10 };
    function resetReadyBall(){
      const p=readyBallPos();
      readyBall.x=p.x; readyBall.y=p.y;
      readyBall.r=clamp(Math.min(W,H)*0.018,8,12);
    }
    resetReadyBall();

    // cooldown
    let sinceShot=999;

    // ===== Asteroids =====
    const asteroids=[];
    let spawnTimer=0, spawnEvery=900, speedBase=140;

    // ===== Particles =====
    const particles=[];

    // ===== Input =====
    let pointerDown=false;
    let pullStart={x:0,y:0};
    let pullNow={x:0,y:0};
    let pullPower=0;   // 0..1
    let pullValid=false;

    // ===== Audio =====
    let audioCtx=null;
    function beep(freq=440,dur=0.05,type='sine',gain=0.03){
      try{
        if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
        const t0=audioCtx.currentTime;
        const o=audioCtx.createOscillator();
        const g=audioCtx.createGain();
        o.type=type;
        o.frequency.setValueAtTime(freq,t0);
        g.gain.setValueAtTime(gain,t0);
        g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(t0); o.stop(t0+dur);
      }catch{}
    }

    // ===== Game functions =====
    function resetGame(){
      score=0; scoreTxt.textContent='0';
      asteroids.length=0;
      particles.length=0;
      balls.length=0;

      spawnTimer=0; spawnEvery=900; speedBase=140;
      pointerDown=false; pullPower=0; pullValid=false;
      sinceShot=999;

      gameOver=false;
      resetReadyBall();
    }

    function endGame(){
      running=false; gameOver=true;

      if(score>highScore){
        highScore=score;
        sessionStorage.setItem(HS_KEY,String(highScore));
        highTxt.textContent=String(highScore);
      }

      overlay.style.display='grid';
      const h1=overlay.querySelector('h1');
      const p=overlay.querySelector('p');
      h1.textContent = (score>=highScore && score>0) ? 'New High Score!' : 'Game Over';
      p.innerHTML = `<b>Shoot the asteroids.</b> Score: <b>${score}</b> • High: <b>${highScore}</b>`;
      startBtn.textContent='Try again';
    }

    function spawnAsteroid(){
      const r=rand(14,26)*(Math.min(W,H)/700);
      const x=rand(r+8,W-r-8);
      const y=-r-8;
      const drift=rand(-50,50);
      const speed=speedBase+rand(0,90)+Math.min(260,score*1.25);
      asteroids.push({x,y,r,vx:drift,vy:speed,spin:rand(-3,3),a:rand(0,Math.PI*2)});
    }

    function explode(x,y,base=14){
      const n=Math.floor(base+rand(0,base));
      for(let i=0;i<n;i++){
        const ang=rand(0,Math.PI*2);
        const sp=rand(80,320);
        particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,r:rand(1.2,2.8),life:rand(0.25,0.6),t:0});
      }
    }

    function shootFromPull(){
      if(!pullValid) return;
      if(sinceShot < TUNE.shotCooldown) return;

      const dx=pullStart.x - pullNow.x;
      const dy=pullStart.y - pullNow.y;
      const mag=Math.hypot(dx,dy);
      if(mag<10) return;

      const maxPull = Math.min(H*TUNE.maxPullFrac, TUNE.maxPullPxCap);
      const raw = mag;

      // prefer pulls that go downward (dy positive means user dragged down)
      const downBias = dy < 0 ? 0.25 : 1.0;

      pullPower = clamp((raw * downBias) / maxPull, 0, 1);

      const dirx=dx/mag;
      const diry=dy/mag;

      const speed = TUNE.launchSpeedMin + (TUNE.launchSpeedMax - TUNE.launchSpeedMin) * pullPower;

      // spawn a new shot ball immediately (rapid-fire)
      const sx = clamp(pullStart.x, readyBall.r+2, W-readyBall.r-2);
      const sy = clamp(pullStart.y, zoneTop()+readyBall.r+8, H-readyBall.r-8);

      let vx = dirx * speed;
      let vy = diry * speed;

      // Strong upward bias so even messy pulls feel good
      if(vy > -TUNE.upwardBiasMin) vy = -TUNE.upwardBiasMin - 680 * pullPower;

      balls.push({ x:sx, y:sy, vx, vy, r:readyBall.r, alive:true });

      sinceShot = 0;
      beep(560,0.04,'triangle',0.03);

      // instantly "re-ready" a new ball
      // (visually, ready ball stays there; we just allow immediate next pull)
    }

    // ===== Input handlers =====
    function getPoint(e){
      if(e.touches && e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY};
      return {x:e.clientX,y:e.clientY};
    }

    function onDown(e){
      if(!running) return;
      const p=getPoint(e);
      pointerDown=true;
      pullStart=p;
      pullNow=p;
      pullPower=0;
      pullValid = (p.y >= zoneTop());
      // If press is above zone, still let them start lower by dragging into zone? Keep it strict for now.
    }

    function onMove(e){
      if(!running || !pointerDown) return;
      const p=getPoint(e);
      pullNow=p;
      if(!pullValid) return;

      const dy=p.y - pullStart.y;
      const dx=p.x - pullStart.x;
      const raw=Math.hypot(dx,dy);
      const downBias = dy < 0 ? 0.25 : 1.0;
      const maxPull = Math.min(H*TUNE.maxPullFrac, TUNE.maxPullPxCap);
      pullPower = clamp((raw * downBias) / maxPull, 0, 1);
    }

    function onUp(e){
      if(!running) return;
      if(pointerDown && pullValid) shootFromPull();
      pointerDown=false;
      pullPower=0;
      pullValid=false;
    }

    canvas.addEventListener('pointerdown',(e)=>{canvas.setPointerCapture?.(e.pointerId);onDown(e);},{passive:true});
    canvas.addEventListener('pointermove',onMove,{passive:true});
    canvas.addEventListener('pointerup',onUp,{passive:true});
    canvas.addEventListener('pointercancel',onUp,{passive:true});

    document.addEventListener('touchmove',(e)=>{ if(running) e.preventDefault(); },{passive:false});

    // ===== Main loop =====
    let lastT=0;
    function step(t){
      requestAnimationFrame(step);
      const dt=Math.min(0.033,(t-lastT)/1000 || 0.016);
      lastT=t;

      // stars drift
      for(const s of stars){
        s.y += s.s*60*dt;
        if(s.y > H+2){ s.y=-2; s.x=Math.random()*W; }
      }

      if(running && !gameOver) update(dt);
      render(dt);
    }

    function update(dt){
      sinceShot += dt;

      // difficulty
      spawnEvery = clamp(900 - score*2.2, 260, 900);
      speedBase  = 140 + Math.min(240, score*0.95);

      // spawn asteroids
      spawnTimer += dt*1000;
      while(spawnTimer >= spawnEvery){
        spawnTimer -= spawnEvery;
        spawnAsteroid();
        if(Math.random()<0.14) spawnAsteroid();
      }

      // update shot balls
      for(let i=balls.length-1;i>=0;i--){
        const b=balls[i];
        b.vy += 620*dt; // a bit more gravity so it comes back faster
        b.x  += b.vx*dt;
        b.y  += b.vy*dt;

        // wall bounce
        if(b.x < b.r){ b.x=b.r; b.vx*=-0.85; }
        if(b.x > W-b.r){ b.x=W-b.r; b.vx*=-0.85; }
        if(b.y < b.r){ b.y=b.r; b.vy*=-0.82; }

        // quick cleanup if it falls below a threshold (rapid reset feel)
        if(b.y > H*TUNE.ballAutoResetY + 120){
          balls.splice(i,1);
          continue;
        }

        // collisions with asteroids
        for(let j=asteroids.length-1;j>=0;j--){
          const a=asteroids[j];
          const rr = a.r + b.r;
          if(dist2(a.x,a.y,b.x,b.y) <= rr*rr){
            score += 10;
            scoreTxt.textContent=String(score);

            // kick ball a bit
            const nx=b.x-a.x, ny=b.y-a.y;
            const nm=Math.hypot(nx,ny)||1;
            b.vx += (nx/nm)*140;
            b.vy += (ny/nm)*140;

            explode(a.x,a.y,16);
            beep(240 + Math.min(900, score*2), 0.04, 'square', 0.025);

            asteroids.splice(j,1);
            break;
          }
        }
      }

      // update asteroids
      const bottomLine = zoneTop() + 12;
      for(let i=asteroids.length-1;i>=0;i--){
        const a=asteroids[i];
        a.a += a.spin*dt;
        a.x += a.vx*dt;
        a.y += a.vy*dt;
        if(a.x < -a.r) a.x = W + a.r;
        if(a.x > W + a.r) a.x = -a.r;

        if(a.y + a.r >= bottomLine){
          explode(a.x,a.y,22);
          beep(120,0.12,'sawtooth',0.03);
          endGame();
          break;
        }

        if(a.y - a.r > H + 200) asteroids.splice(i,1);
      }

      // particles
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.t += dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= Math.pow(0.08, dt);
        p.vy *= Math.pow(0.08, dt);
        if(p.t >= p.life) particles.splice(i,1);
      }
    }

    function render(dt){
      ctx.fillStyle='#070A12';
      ctx.fillRect(0,0,W,H);

      // vignette
      const vg=ctx.createRadialGradient(W*0.5,H*0.35,10,W*0.5,H*0.5,Math.max(W,H));
      vg.addColorStop(0,'rgba(120,160,255,0.08)');
      vg.addColorStop(0.6,'rgba(0,0,0,0)');
      vg.addColorStop(1,'rgba(0,0,0,0.55)');
      ctx.fillStyle=vg;
      ctx.fillRect(0,0,W,H);

      // stars
      ctx.fillStyle='rgba(255,255,255,0.75)';
      for(const s of stars){
        ctx.globalAlpha=clamp(0.35 + s.r*0.25,0.25,0.9);
        ctx.beginPath();
        ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha=1;

      // pull guide
      if(running && pointerDown && pullValid){
        const sx=pullStart.x, sy=pullStart.y;
        const ex=pullNow.x,   ey=pullNow.y;

        ctx.lineWidth=3; ctx.lineCap='round';
        ctx.strokeStyle=`rgba(255,255,255,${0.20 + 0.45*pullPower})`;
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();

        ctx.strokeStyle=`rgba(120,160,255,${0.22 + 0.55*pullPower})`;
        ctx.lineWidth=7;
        ctx.beginPath(); ctx.arc(sx,sy,12 + 34*pullPower,0,Math.PI*2); ctx.stroke();
      }

      // asteroids
      for(const a of asteroids){
        const ag=ctx.createRadialGradient(a.x-a.r*0.25,a.y-a.r*0.25,2,a.x,a.y,a.r*1.2);
        ag.addColorStop(0,'rgba(255,255,255,0.18)');
        ag.addColorStop(0.4,'rgba(180,190,210,0.14)');
        ag.addColorStop(1,'rgba(80,90,120,0.55)');
        ctx.fillStyle=ag;
        ctx.beginPath(); ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.fill();

        ctx.globalAlpha=0.65;
        ctx.fillStyle='rgba(0,0,0,0.25)';
        for(let i=0;i<3;i++){
          const cx=a.x + Math.cos(a.a+i)*a.r*0.35;
          const cy=a.y + Math.sin(a.a*1.2+i*1.7)*a.r*0.25;
          ctx.beginPath(); ctx.arc(cx,cy,a.r*rand(0.12,0.22),0,Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha=1;

        ctx.strokeStyle='rgba(255,255,255,0.10)';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.stroke();
      }

      // shot balls
      for(const b of balls){
        const bg=ctx.createRadialGradient(b.x-b.r*0.3,b.y-b.r*0.3,2,b.x,b.y,b.r*1.6);
        bg.addColorStop(0,'rgba(255,255,255,0.95)');
        bg.addColorStop(0.4,'rgba(120,160,255,0.75)');
        bg.addColorStop(1,'rgba(255,120,180,0.20)');
        ctx.fillStyle=bg;
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.18)';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.stroke();
      }

      // ready ball (always available)
      if(running){
        const rbX = pointerDown && pullValid ? pullStart.x : readyBall.x;
        const rbY = pointerDown && pullValid ? pullStart.y : readyBall.y;
        const r = readyBall.r;

        const rg=ctx.createRadialGradient(rbX-r*0.3,rbY-r*0.3,2,rbX,rbY,r*1.6);
        rg.addColorStop(0,'rgba(255,255,255,0.85)');
        rg.addColorStop(0.4,'rgba(120,160,255,0.55)');
        rg.addColorStop(1,'rgba(255,120,180,0.12)');
        ctx.fillStyle=rg;
        ctx.beginPath(); ctx.arc(rbX,rbY,r,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.10)';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(rbX,rbY,r,0,Math.PI*2); ctx.stroke();
      }

      // particles
      for(const p of particles){
        const a=1-(p.t/p.life);
        ctx.globalAlpha=a;
        ctx.fillStyle='rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=1;

      // danger line
      ctx.strokeStyle='rgba(255,255,255,0.10)';
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,zoneTop()); ctx.lineTo(W,zoneTop()); ctx.stroke();

      // dim when not running
      if(!running){
        ctx.fillStyle='rgba(0,0,0,0.25)';
        ctx.fillRect(0,0,W,H);
      }
    }

    // ===== Start button =====
    function startGame(){
      overlay.style.display='none';
      resetGame();
      running=true;
      gameOver=false;

      // iOS audio unlock
      if(!audioCtx){
        try{
          audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          const o=audioCtx.createOscillator();
          const g=audioCtx.createGain();
          g.gain.value=0.00001;
          o.connect(g); g.connect(audioCtx.destination);
          o.start(); o.stop(audioCtx.currentTime+0.01);
        }catch{}
      }
    }
    startBtn.addEventListener('click',startGame);

    // keep ready ball positioned on resize
    window.addEventListener('resize', () => { resetReadyBall(); }, { passive:true });

    requestAnimationFrame(step);
  </script>
</body>
</html>